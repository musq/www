---
layout: post
title: Object Oriented Analysis and Design
categories: Tutorial
---

What is an object?

This document is a summary of Object Oriented Analysis and Design (OOAD)
techniques. This is not intended for a newbie. If you face problems
understanding any part, I suggest either of the following:

- Read the book *[Object-Oriented Analysis and Design with Applications - by Grady Booch, et.al](https://www.oreilly.com/library/view/object-oriented-analysis-and/9780201895513/)*
- Watch the course *[Object Oriented Analysis
and Design - by Prof. Partha Pratim Das](https://www.youtube.com/playlist?list=PLJ5C_6qdAvBHslIkD7JB7kBdgv1SeXy3P)*
- Jump to [Example - Leave Management System](#example---leave-management-system) section to follow an example of OOAD to build a Leave Management System

## Table of Contents

1. [Introduction](#introduction)
    - [The Problem](#the-problem)
    - [What are Objects?](#what-are-objects)

1. [Object Oriented Approach](#object-oriented-approach)
    - [Nature of objects](#nature-of-objects)
        - [State](#state)
        - [Behaviour](#behaviour)
        - [Identity](#identity)

    - [Relationship among objects](#relationships-among-objects)
        - [Links](#links)
        - [Aggregation](#aggregation)

    - [Nature of class](#nature-of-class)
        - [Design by Contract](#design-by-contract)
        - [Interface](#interface)
        - [Visibility](#visibility)
        - [Implementation](#implementation)

    - [Relationship among classes](#relationship-among-classes)
        - [Association](#association)
        - [Inheritance](#inheritance)
        - [Polymorphism](#polymorphism)
        - [Aggregation](#aggregation-1)

1. [Building quality classes and objects](#building-quality-classes-and-objects)
    - [Measures of quality](#measures-of-quality)
        - Coupling
        - Cohesion
        - Sufficiency
        - Completeness
        - Primitiveness

    - [Choosing operations](#choosing-operations)
        - Functional semantics
        - Time and space semantics

    - [Choosing Relationships](#choosing-relationships)
        - Law of Demeter
        - Mechanisms and Visiblity

    - [Choosing Implementations](#choosing-implementations)
        - Representation for a class or object
        - Placement of the class or object in a module

1. [Classification](#classification)
    - [Clustering](#clustering)
        - Structural clustering
        - Conceptual clustering
        - Prototype theory

    - [Indentification](#identification)
        - Key abstractions
            - Discovery
            - Invention

    - [How to apply?](#how-to-apply)

1. [Example - Leave Management System](#example---leave-management-system)
    - [Identification of classes](#identification-of-classes)
        - Extraction of nouns
        - Identification of Attributes
        - Structural clustering
        - Behavioral clustering
        - Resultant Classes

    - [Identification of Responsibilities](#identification-of-responsibilities)
        - Extraction of verbs
        - Relation of verbs with classes

    - [Classification of Relationships](#classification-of-relationships)
        - Collaboration
        - Modularization
        - Hierarchy

1. [Further Reading](#further-reading)
    - Design Patterns
    - Test Driven Development
    - Data Structures and Algorithms


## Introduction

You'd have heard of Object Oriented Programming long back in college.
Everybody was doing OOP and you didn't know why. I didn't know OOP up
until a while back. One evening I took a long walk with my friend
[Sudhir](https://twitter.com/sudhirmith) asking him all about
Interfaces, Abstract classes, Encapsulation, Inheritance, Polymorphism,
etc. He was patient enough to answer all my questions. I was starting to
get it. **However I still kept asking myself - Why?**

- Why do we have to do this?
- Why do we have to have OOP?
- What is the problem that it's solving?
- What is an object?

We came back home, I being half full, half empty. As a result I was
restless for a couple of months. Then I started a thought experiment - If I had to design a
new software from scratch, how would I go about doing it?

- First, I would want to choose a Programming Language (PL) and learn
all possible semantics and syntax so I can be fully efficient during
coding
- Next I will decide all the services that my software would offer
- Then I would identify all the modules that would be needed to create
those services
- Next, for each module I would want to create CRUD APIs
- Then, I would want some APIs for the modules to talk to each other
- Finally, I would want some APIs to control those services
individually

Now, not all of those APIs need to be public. Only the service level
APIs should be publically exposed, almost all others can be
private/internal to my software that the world doesn't need to know
about.

### The Problem

How do I start deciding what are the top level services? How do we start
classifying the names of modules? How do we determine which internal
APIs will be needed? I wasn't able to arrive at a solution to these
questions even after long self-deliberation. **It was getting chaotic.**
So I started searching for video lectures on NPTEL. I didn't know what I
was looking for, but it should belong to Computer Science and Software
Engineering domain. That's when I encountered *[Object Oriented Analysis
and Design - by Prof. Partha Pratim Das](https://www.youtube.com/playlist?list=PLJ5C_6qdAvBHslIkD7JB7kBdgv1SeXy3P)*. I stumbled upon the title of its
Chapter 7 - "Bringing order to chaos". This is it!


### What are Objects?

Imagine a nano computer. It can accept computing instructions and input
data (on which computation will be done) from other similar computers.
Likewise it can also send computing instructions and the computed data
to other such computers. So, in the end you'll end up with a
mesh/network of nano computers which are performing their computations
locally on *their* data and are passing messages (instructions/data) to
other similar computers synchronously/asynchronously. Such a contrained
virtual computer is called an object.

> An object is a unit of computing entity which can perform a set of
> pre-defined computations on pre-defined types of data

## Object Oriented Approach

A software written using OOP will be composed of such a network of
objects. There are 3 steps in the object-oriented approach to software
development:

1. **Analysis** --- We analyse the requirements and write down everything that
   seems relevant. Then we try to figure out all types of objects that
   we'll need and determine relationships among them.
2. **Design** --- Once we have an overview of all objects , we filter out the
   redundant ones. We finalise our objects list and fix their
   responsiblities and dependencies. We may use UML diagrams to assist
   us here.
3. **Programming** --- Finally we look at how our Programming Language (PL)
   assists us in the architecture of our objects, overall design, and
   implementation.

> OOP is the final step in building software the object-oriented way.
> OOAD comes before it.

## Nature of objects

An object is defined by 3 things:
1. State
1. Behaviour
1. Identity

### State

Properties/Attributes that you define in the constructor of a class.
This is the local data on which computation will be done. An object's
state depends on all possible values its properties are allowed to have.
There could be 2 types of properties:
- **Static** --- e.g. color of car
- **Dynamic** --- e.g. is the car moving?
  - You should define all the constraints - e.g. `isCarMoving` must be
    boolean

> Getting in an invalid state is bad and must raise an exception.

### Behaviour

Methods/Functions that you define in rest of the class. These are the
instructions on how to perform computation on local data. It specifies
how an object acts and reacts, in terms of its state changes and message
passing. So behaviour is responsible for mutating state. The state of an
object represents the cumulative results of its behaviour.

- **Roles** --- The behaviour of an object can be logically grouped
  based on commonality and interdependence. These denote the roles an
  object can play.
- **Responsibilities** --- Every role is characterized by the services
  rendered for the role. These are called responsibilities.

e.g. In Leave Management System (LMS), we could have following roles
and corresponding resposibilities:
- `Developer` - recordAttendance(), requestLeave(), cancelLeave()
- `Lead` - Developer's responsiblities + approveLeave(),
  revokeLeave()
- `Manager` - Lead's responsibilties + creditDebitLeave()

There could be 5 types of methods:
- **Modifier** - change state e.g. `push()`, `pop()`
- **Accessor** - access state e.g. `top()`, `empty()`
- **Iterator** - go over all parts of object and do some operation e.g.
  `print()`
- **Constructor** - create object and initialize state
- **Destructor** - free state and destroy object

### Identity

That property of an object which distinguishes it from all other
objects. Objects may be distinguishable by either of following:

- the state if it has at least one unique property. e.g. employee_id
- an identity ascribed by system. e.g. Java frameworks attach a
  unique ID to each object instance, `id(obj)` in python yields the
  ID of object `obj`.

**Space for an object** - All objects within a system (running instance of
a software) encapsulate some state. Objects reside in memory (RAM).
Creating objects without destroying them (after use) will soon fill up
all the memory, so some PLs have garbage collectors that automatically
clean up unused objects to free up memory.

## Relationships among objects

Objects contribute to the behaviour of a system by collaborating with
one another.

### Links

Peer-to-peer communication between objects. Physical or conceptual
connection between objects. e.g. - my bank account has account type,
transactions allowed, balance.

Communicate by passing messages to the other object:
- Invoke/apply services of another object
- Navigate to another object

Roles of participating objects in a link:
- ***Controller/Active*** --- Can only request services from other
  objects
- ***Server*** --- Can only respond to requests from other objects
- ***Proxy*** --- Can do both, interchangebly or simultaneously

**Visibility**: Important for communication between objects
- Public
- Package
- Protected
- Private

**Synchronization**: Important when 2 or more threads are using the same
object
- ***Active/Client*** --- Instigates interaction in a thread
  - Can change its own state
  - Send message to other objects if necessary
  - Responsible for handling control to other objects
- ***Passive/Server*** --- Wait for the message to be processed
  - Activated when receive message from other objects
  - Waits for another object that requires its services

**Different situations in synchronization**

For objects with multiple threads of control, synchronization needs to
ensure mutual exclusion to resolve issues of concurrency. e.g. 2
simultaneous write operations on an object must be made sure to be
mutually exclusive.
- *Sequential* - e.g. Only one computer talks to the printer at a time
  - Passive object linked to single active object
    - Active objects must coordinate outside the object so that only one
    flow is in object at a time
  - For multiple flows of control, integrity is not guaranteed
- *Guarded* - e.g. Multiple computers queue their requests to a central
  computer which talks to the printer
  - Clients coordinate for mutual exclusion
  - Integrity is guranteed - Serialize all calls to all of the object's
    guarded operations
  - Exactly one operation at a time can execute on the object,
    reducing this to sequential semantics (Beware of deadlocks)
- *Concurrent* - Printer manages queue for requests from multiple
  computers
  - Server coordinates for mutual exclusion
  - Integrity is guranteed - Multiple flows access disjoint sets of
    data or only read data (Beware - crafty design required)

### Aggregation

An object is a collection of other objects.
- **HAS_A** (strong aggregation): Physical containment is necessary.
  e.g. Library has books
- **HAS** (weak aggregation): Conceptual aggregation. e.g. Library has
  users

> - Aggregation is sometimes better because it encapsulates parts as
>   secrets of the whole.
> - Links are sometimes better because they permit looser coupling among
>   objects.

## Nature of class

A class is a set of objects sharing a common structure, common
behaviour, and common semantics.

> Class is template (blueprint) for an object.
>
> Object is an instance of a class.

While anything can be a class, the attributes of a complex system should
be carefully crafted in designing a class. Keep in mind:
- Hierarchic structure
- Relative primitives
- Separation of concerns
- Common patterns
- Stable intermediate forms

### Design by Contract

A metaphoric approach to design, based on how elements of a software
system collaborate with each other on the basis of mutual *obligations*
and *benefits*.

A *client* and *supplier* must aggree on a *contract*:
- **Supplier** must provide certain product (*obligation*) and is entitled
  to expect that *client* has paid its fee (*benefit*)
- **Client** must pay the fee (*obligation*) and is entitled to get the
  product (*benefit*)
- Both parties must satisfy certain *obligations*, such as laws and
  regulations, applying to all *contracts*

For a class in OOP with methods:
- **Precondition** is to be *guaranteed on entry* by any client that
  invokes the message --- an *obligation* for the client, and a *benefit*
  for the server (the method itself), as it frees it from having to
  handle cases outside of precondition
- **Postcondition** is a *guaranteed on exit* from the routine --- an
  *obligation* for the server, and obviously a *benefit* (invoking the
  message) for the client
- Maintain a certain property, assumed on entry and guaranteed on exit
  --- the class **invariant**
- Some **side effect** occurs

### Interface

- Provides an **outside view**
- Emphasizes the abstraction while hiding its structure and the secrets
  of its behaviour

The interface applies to all instances of a class and comprises:
- *Methods* that are publicly visible
- *Contracts* for the methods

e.g. An interface for a stack:

**Method** | **Precondition** | **Postcondition** | **Side-effect**
Push | Valid object | Object on top | May acquire more memory. Throws exception if low on memory.
Pop | Nil | Top object removed | Throws exception if stack is empty. May release some memory.
Top | Nil | Top object returned. State of stack unchanged | Throws exception if stack is empty.
Empty | Nil | State of stack unchanged |

### Visibility

Enforces grades of *Encapsulation* in a class.

A declaration that is accessible...
- **Public**: to all clients
- **Package**: only by classes in the same package
- **Protected**: only to the class itself and its subclasses
- **Private**: only to the class itself

### Implementation

- Deal with **inside view** which encompass the secrets of its behaviour
- Consists primarily of the implementation of all the operations defined
  in the interface of the class

In an implementation:
- The state of an object must have some representation --- typically
  expressed as *constant and variable declarations* placed in the
  *protected or private* parts of a class' interface
- The representation common to all instances of a class is encapsualted
  --- changes to this representation do not functionally affect any
  outside clients

e.g. A stack defined in the above interface can be *implemented* using:
- static arrays
- dynamic array
- linked list
- vector

## Relationship among classes

### Association

- **Semantic dependencies**
  - Most general and most semantically weak
  - Bidirectional by default
  - Often refined over/after the analysis process

  e.g.

  **Before analysis** | **After analysis**
  Daisy --- Flower | refined to Daisy IS_A Flower
  Flower --- Petal | refined to Flower HAS_A Petal
  Ladybug --- Flower | refined to ?

- **Multiplicity of Relationships (Cardinality)**

  **Type** | **Example**
  One to One | Sale --- CreditCardTransation
  One to Many | Order --- Items
  Many to Many | Customer --- Salesperson

### Inheritance

Relationship type: **IS_A**

- **Generalization/Specialization**
  - Daisy IS_A Flower
  - Daisy will inherit all properties of Flower, and have some more of
    its own
  - Flower is Generalization
  - Daisy is Specialization

- Semantically most interesting
- Can *delegate* behaviour to related objects
- Comes in a number of flavours:
  - **Single / Multi-level / Hierarchical**
    - ***Superclass and Subclass***: They may not be instantiated
      (**Abstract Class**)
      - *Inheritance by extension*: Subclass augments Superclass
        e.g. Eagle IS_A Bird, Sedan IS_A Fourwheeler
      - *Inheritance by restriction*: Subclass constraints
        Superclass. e.g. Ostrich IS_A Bird, Square IS_A Rectangle
    - ***Leaf class***: They must be instantiated (**Concrete Class**)
      - An abstract class will always be non-leaf
      - A non-leaf class is not necessarily abstract - they may be
        concrete class
  - **Multiple**
    - A subclass has multiple superclasses
    - **Name collisions** during multiple inheritance is resolved by
      language semantics in any of the following ways:
      - Regard clash as illegal and reject compilation
      - Regard the same name property as referring to the same attribute
      - Regard the clash, but require all references to the name fully
        qualify the source of its declaration
  - **Hybrid**
    - **Repeated inheritance**
      - Treat occurences of repeated inheritance as illegal
      - Permit duplication of superclass but require the use of fully
        qualified names to refer to members of a specific copy
      - Treat multiple references to the same class as denoting the
        same class

> Try very hard to avoid *Name collisions* and *Repeated inheritance*.

### Polymorphism

One name, multiple behaviour.

e.g. If Vehicles class defines `getNumberOfWheels()`,
- For TwoWheelers (and subclasses), it returns 2
- For ThreeWheelers (and subclasses), it returns 3
- For FourWheelers (and subclasses), it returns 4

But, `getNumberOfWheels()` cannot be invoked on Vehicles! If there
exists at least one method that cannot be invoked on the superclass
but can be invoked on the subclasses, the superclass **must be an
Abstract Class**. So Vehicles is an abstract class and getNumberOfWheels
is an **abstract method**.

For TwoWheelers, getDrivingAge() cannot be invoked, but Bicycle and
Scooter can answer this query. So, TwoWheelers (like Vehicles) should
also be abstract in this context.

> As a convenient rule, if instantiating a class doesn't make sense, or
> feels incomplete, then it should be an Abstract Class.

### Aggregation

Relationship type: **HAS_A**

Aggregation indicates **dependency** --- that an element on one end of
the relationship, in some manner, depends on the element on the other
end of the relationship. e.g. Ladybug protects Flowers

- Whole/Part relationship:
  - Physical containment (**Composition / Strong aggregation**)
  - Flower HAS_A Petal: Flower contains many Petals
- Member relationship:
  - Conceptual containment (**Weak aggregation**)
  - Library HAS_A Member: Library does not contain Members

## Building quality classes and objects

4 issues that need to be taken care of:

### Measures of Quality

- Coupling
  - Measures strength of association established by a connection from
    one module to another
  - **Low inter-class coupling is desirable**
  - Traffic across modules should be significantly low
  - *Inheritance is highly coupled!*
- Cohesion
  - **High intra-class cohesion is desirable**
  - Traffic within a module should be significantly high
- Sufficiency
  - The class or module captures enough characteristics of the
    abstraction to permit meaningful and efficient interaction
  - **Leads to minimalistic design**
  - e.g. Do not implement doublePush() or triplePush() in a Stack
- Completeness
  - The interface of the class or module captures all of the meaninful
    characteristics of the abstraction
  - **No aspects of the abstraction is missed out**
  - e.g. Must implement empty() in Stack as defined in the contractual
    guarantees in the interface
- Primitiveness
  - Primitive operations are those that can be **efficiently
    implemented**
  - e.g. dunder methods in Python (`__len__()`, `__str__()`, etc.)

### Choosing Operations

Crafting an interface involves the decision about:

- Functional Semantics
  - Too fine - Too coarse trade-off
  - **A good designer knows how to find the appropriate balance between
    too much contracting, which produces fragmentation, and too
    little, which yields unmanageably large modules**

    e.g. Should your implementation of top() in stack return null or
    the top element? Should you write a function to increment the
    value of a variable by N?
  - Factors affecting this decision:
    - Reusability --- Would this behaviour be more useful in more than
      one context?
    - Complexity --- How difficult is it to implement the behaviour?
    - Applicability --- How relevant is the behaviour to the type in
      which it might be placed?
    - Implementation Knowledge --- Does the behaviour's implementation
      depend on the internal details of a type?
- Time and Space Semantics
  - Specify the amount of time an operation should take
  - Specify the amount of space an operation should take
  - This semantics is typically analyzed for --- best, average and worst
    cases
  - Consider the need for synchronization for message passing (objects
    may be in multiple threads, not in simple function invocation)

### Choosing Relationships

- **Law of Demeter**
  - The methods of a class should not depend in any
    way on the structure of any class, except the immediate (top-level)
    structure of their own class. Further, each method should send
    messages to objects belonging to a very limited set of classes only.
  - Class hierarchy:
    - **Wide and Shallow** --- Forest of classes are more loosely
      coupled but they may not exploit all the commonality that exists
    - **Narrow and Deep** --- Long chain of inheritance is tightly
      coupled
    - **Balanced** --- Between the two extremes
  - Similar trade-offs among *inheritance*, *aggregation*, *dependency*
  - Inheritance is appropriate if every instance of B may also be
    viewed as an instance of A. The client relationship is appropriate
    when every instance of B simply possesses one or more attributes
    of A
  - Should class Car *inherit*, *contain*, or *use* classes - Engine
    and Wheel?

- **Mechanisms and Visibility**
  - Deciding on the relationship among objects is a matter of
    designing the mechanisms whereby these objects interact
  - A *Passenger* intends to *board* a *Bus*. Where should the board
    operation go?
    - *Passenger* - Passenger must be visible to the Bus, because
      Passenger must know which Bus she's getting into
    - *Bus* - Bus must be visible to the Passenger
    - Both - There must be mutual visibility
    - Further, visibility relationship between Bus and Driver must be
      clear while the same between Passenger and Driver need not be
      there

### Choosing Implementations

- Representation for a class or object
  - Representation should be one of the encapsulated secrets of the
    abstraction
  - Possible to change the representation without violating any of the
    functional assumptions that clients may have made
  - **The choice of representation is often a fairly difficult one,
    and it is not uniquely determined by the facilities available. It
    must always be taken in light of the operations that are to be
    performed upon the data**
  - What has priority?
    - Time or Space
    - Search or Insert/Delete
    - Compute or Cache
- Placement of the class or object in a module
  - How to put Classes and Objects in Modules?
  - Visibility and Information hiding trade-off: **Applying this
    principle is not always easy. It attempts to minimize the expected
    cost of software over its period of use and requires that the
    designer estimate the likelihood of changes. Such estimates are
    based on past experiences and usually require knowledge of the
    application area as well as an understanding of hardware and
    software technology**
  - Many non-technical factors: matters of reuse, security,
    documentation, etc.

## Classification

2 step identification of Classes:

### Clustering

- **Structural clustering**
  - Divide objects into disjoint sets depending on the presence or
  absence of a particular property
- **Conceptual clustering**
  - Attempts to explain how knowledge is represented
  - More knowledge about a domain makes it easier to achieve an
    intelligent classification
- **Prototype theory**
  - Some abstractions neither have clearly bounded properties nor
    concepts. e.g. Game:
    - No common properties shared by all games
    - The category of games is united by what Wittgenstein calls
      *family resemblances*
    - New kinds of games introduced, provided that they resembled
      previous games in appropriate ways
  - A class of objects is represented by a prototypical object, and
  - An object is considered to be a member of this class if and only
    if it resembles this prototype
  - e.g. for games like Chess, Soccer, Wrestling, Swimming
    - Chinese checker resembles Chess
    - Kabbaddi resembles Wresting

### Identification

- **Key abstractions**
  - Forms the vocabulary of the problem domain
  - Gives boundaries to the problem
  - Highlight the things that are in the system
  - Identification of key abstractions is highly domain specific
  - Identification involves two processes:
    - **Discovery**:
      - A client using an ATM speaks in terms of accounts, deposits,
        withdrawals, etc.
      - These words are part of vocabulary of the problem domain
    - **Invention**:
      - A developer creating an ATM uses these abstractions but must
        also introduce new ones, such as databases, screen managers,
        lists, queues, etc.
      - **OOAD involves mapping the Client abstractions with the
        Developer abstractions**


### How to apply?

- Identify classes and objects first according to the *properties
  relevant to the particular domain*. Focus on identifying *Structures
  and Behaviours*
- If this approach fails to yield a satifactory class structure, next
  consider *clustering objects by concepts* (or refining our initial
  domain-based classification by concepts). Focus on *Behaviour of
  collaborating objects*
- If either of these two approches fails, consider *Classification by
  Association*, through which clusters of objects are defined according
  to how closely each resembles some prototypical object
- Once classified, try to identify *Key Abstractions*


OOAD is an iterative refinement process:
- Start somewhere
- Apply some methods
  - Clustering
  - Identification
- Make hypothesis, make a design
- Check how you're doing on the quality of design
- If needed, refine the design by
  - Acquiring more knowledge about system
  - Going back to customer for clarity
  - Learning more about the domain

## Example - Leave Management System

For OOAD you must describe the problem as requirement specification in
as detail as possible. Let's create a Leave Management System (LMS) and
take following things into account:
- Types of members in an organization
- Roles and responsiblities of members
- Types of leaves

### Identification of classes

- Extraction of nouns:
  - Process:
    - Elimination of irrelevant terms
    - Elimination of names of values
    - Elimination of vague terms
    - Identification of attributes
    - Identification of operations
    - Elimination of terms which are in fact relationships

  - e.g.
    - Write all the nouns that come to your mind like: Employee, Age,
      Seniority, Marital Status, Height, Weight, etc.
    - Then we'll discard nouns like Height, Weight, etc. because they
      aren't relevant in creating an LMS.
  - Quality Checks:
    - Metrics:
      - Coupling: Very low
      - Cohesion: Very low
      - Sufficiency: Unclear
      - Completeness: Unclear
      - Primitiveness: Unclear
    - Actions required:
      - Identify Attributes
      - Perform Structural Clustering

- Identification of Attributes:
  - A noun used only to store values should be treated as Attribute
    - Static value
    - Dynamic value
  - e.g. LoginID, Name, Employee Code, Personal Details, Salary

- Structural Clustering:
  - Process:
    - People:
      - Manager, Lead, Executive
      - SysAdmin
    - Organization:
        - Company
    - Things (Documents):
      - Medical certificate, Parenthood certificate
    - Events:
      - Holiday, Disciplinary actions, CL, ML, UL, etc.
    - Temporal nouns:
      - Date, Year, Time, Days, Calendar Year, Week, Month
    - Incidental nouns:
      - Leave Rules, Administrative Functions, Period
  - Quality Check:
    - Metrics:
      - Coupling: **Low** (was Very low)
      - Cohesion: **Low** (was Very low)
      - Sufficiency: Unclear (was Unclear)
      - Completeness: Unclear (was Unclear)
      - Primitiveness: Unclear (was Unclear)
    - Actions required:
      - Perform Behavioural Clustering

- Behavioural Clustering:
  - Process:
    - What takes place in the system?
      - Leaves: CL, ML, UL, etc.
    - Initiator and Participant
      - Initiator: Lead, Manager, SysAdmin
      - Participant: Executive, Lead, Manager

  - Abstractions summary from Linguistic Analysis:
    - **Key Abstractions**: *Appear frequently*. Leave, Employee, CL,
      EL, etc.
    - **Non-Key (Supporting) Abstractions**: *Appear less frequently*.
      Medical certificate, Parenthood certificate, Disciplinary actions
    - **Incidental Abstractions**: Leave status, Administrative
      functions
    - **Attribute (Property) Abstractions**: Name, Personal details,
      Employee code

  - Quality Check:
    - Metrics:
      - Coupling: Low (was Low)
      - Cohesion: **Moderate** (was Low)
      - Sufficiency: Unclear (was Unclear)
      - Completeness: **Very low** (was Unclear)
      - Primitiveness: **Very low** (was Unclear)
    - Actions required:
      - Decide on Classes (first level)

- Resultant Classes:
  - All the Key Abstractions will be classes at this stage
  - Company, Employee, Executive, Lead, Manager, Leave, SL, ML, PL,
    CL, EL, DL, LWP, UL, SysAdmin


### Identification of Responsibilities

- Extraction of Verbs:
  - Which operations can be executed by a certain object?
  - Not only the current requirements should be considered, but also
    the re-usability should be taken into account
  - Which events are expected?
  - Which objects can react to these events?
  - Which other events are raised in turn?
  - Reject contraint verbs: e.g. allowed, etc.

- Relation of Verbs with Classes:
  - Process:
    - Employee:
      - Generic actions: Record, Request, Cancel, Avail, Check, Export
      - Specific actions: Work, Report, Approves, Regret
    - Casual Leave:
      - Credit, Prorate, Approve, Cannot be availed, Cannot be clubbed

  - Abstraction summary from Linguistic Analysis:
    - **Key Abstractions**: Report, Request, Approve, Regret
    - **Non-Key (Supporting) Abstractions**: Can be clubbed
    - **Auxiliary Actions**: Perform

  - Results:
    - Define attributes and responsibilites of each class
    - e.g. Employee:

      **Attributes**   | **Responsibilities**
      Name             | Record daily attendance
      Personal details | Request for leave
      Designation      | Cancel an approved leave not yet availed
      Employee code    | Avail leave (if approved)
      Login ID         | Check/Export own Leave Status for a period

    - Similarly define for Executive, Lead, and Manager

    - e.g. Leave:

      **Attributes** | **Responsibilities**
      Type of leave  | Validity checking
      Start date     | Accounting
      Duration |
      Employee ID |

    - Similarly define for CL, EL, ML, etc.

  - Quality Check:
    - Metrics:
      - Coupling: Low (was Low)
      - Cohesion: Moderate (was Moderate)
      - Sufficiency: **Very low** (was Unclear)
      - Completeness: **Low** (was Very low)
      - Primitiveness: Very low (was Very low)
    - Actions required:
      - Explore Association
        - Identify possible relationships/collaboration between
          classes
        - For those with relationships, describe the nature of the
          relationship
        - Identify the Hierarchy between related classes

### Classification of Relationships

- Collaboration:

  **Class** |     **Responsibilities**      |    **Collaborators**
  Company   |     Manage                    |         Employee
            |                               |         Leave
  Employee  |     Record daily attendance   |         Leave
            |     Request for leave |
  Executive |     Record daily attendance   |         Leave
            |     Request for leave         |         Lead
  Lead      |     Approve leave             |         Leave
            |     Request for leave         |         Executive
            |                               |         Manager
  Manager   |     Credit/Debit/Adjust leave |         Leave
            |     Hire/Fire Employee        |         Executive
            |     Force-execute             |         Lead
            |                               |         SysAdmin
  Leave     |     Validity checking         |         Employee
            |     Accounting |
  CL        |     Credit, Prorate           |         Employee
            |     Count, Club               |         Leave
  SL        |     Credit, Carry over        |         Employee
            |     Prorate, Club             |         Leave
  EL        |     Credit, Carry over        |         Employee
            |     Accumulate, Encash        |         Leave
  DL        |     Create                    |         Employee
            |                               |         Leave
  PL        |     Credit, Prorate           |         Employee
            |     Count, Club               |         Leave
  ML        |     Count, Club               |         Employee
            |                               |         Leave
  LWP       |     Avail, Club               |         Employee
                                            |          Leave

- Modularization:
  - Depending upon the collaboration of the classes we can decompose
    the system into cohesive and loosely coupled modules
  - Objective is to define the boundary
  - Company --- has ---> Employee --- applyFor ---> Leave
    - *Company*: Company
    - *Employee*: Employee, Executive, Lead, Manager
      - *Leave*: Leave, CL, ML, EL, etc.

  - Quality Check:
    - Metrics:
      - Coupling: Low (was Low)
      - Cohesion: **High** (was Moderate)
      - Sufficiency: **Low** (was Very low)
      - Completeness: Low (was Low)
      - Primitiveness: **Low** (was Very low)
    - Actions required:
      - Explore Hierarchy

- Hierarchy:
  - Re-analyze responsibilites
  - Find Commonality in:
    - Attributes: e.g. Employee: name, id
    - Responsibilites: e.g. Employee: record daily attendance, request
      leave, cancel approved leave, avail leave, if approved
  - To determine direction of hierarchy, find Differences in:
    - Additional Attributes:
      - Executive: reporting_lead
      - Lead: reporting_manager, list of reporting Executives
      - Manager: List of reporting Leads
    - Additional Responsibilities:
      - Executive: Report to Lead
      - Lead: Approve Leave (Executive), Regret Leave (Executive), etc
      - Manager: Approve Leave (Lead), Revoke Leave (Lead), etc

  - So, the hierarchy could be:
    - (Executive, Lead, Manager) IS_A (Employee)

  - Additionally, since Lead is a specialization of Executive, and
    Manager is a specialization of Lead, the hierarchy could also be:
    - (Manager) IS_A (Lead) IS_A (Executive) IS_A (Employee)

  - Similarly, Leave hierarchy could be:
    - (LWP, UL, PL, ML, DL, SL, EL, CL) IS_A (Leave)
    - But this is **Wide and Shallow** (like Forest) - Not good Design

  - Try to analyze requirement specification and find commonality
      like duration, clubbable, pre_approved, unpaid, certification,
      encashable, holiday_exempt
  - Arrange in a tabular form for better visibility and analyze
      - Horizontally
      - Vertically

  **Examples** |
  (DL) IS_A (On_duty) IS_A (Leave) |
  (No_pre_application, Certified, Clubbable, Carry_forward, Encashable, No_pay) IS_A (Not_on_duty) IS_A (Leave) |
  (CL) IS_A (No_pre_application) |
  (PL) IS_A (No_pre_application, Certified, Clubbable) |
  (ML) IS_A (Certified, Clubbable) |
  (SL) IS_A (No_pre_application, Certified, Clubbable, Carry_forward) |
  (EL) IS_A (Clubbable, Carry_forward, Encashable) |
  (LWP) IS_A (Clubbable, No_pay) |
  (UL) IS_A (No_pay) |

    - This is a more balanced hierarchy

  - Quality Check:
    - Metrics:
      - Coupling: **Moderate** (was Low)
      - Cohesion: High (was High)
      - Sufficiency: Low (was Low)
      - Completeness: **Moderate** (was Low)
      - Primitiveness: **Moderate** (was Low)
    - Actions required:
      - Explore deep relationship inside a Module
        - among Employee classes
        - among Leave classes
        - across Employee and Leave classes

## Further Reading

We've covered the Analysis and Design part of object oriented approach
to software development. Hopefully you now have a relatively clearer
view.

In this document I said, we need UML diagrams to assign us in the
designing classes. So you could go [learn about UML
diagrams](https://www.youtube.com/watch?v=iN4Ft6loL7o&list=PLJ5C_6qdAvBHslIkD7JB7kBdgv1SeXy3P&index=33)
as a next step.

If you want to go ahead to OOP, you should pick up your favorite object
oriented programming language (mine is Python) and learn its syntax and
semantics. Then you should read and implement the following (my
suggestions included):

1. Design Patterns ([Practical Python Design Patterns --- Wessel Badenhorst](https://www.apress.com/gp/book/9781484226797))
1. Test Driven Development ([Obey the Testing Goat! --- Harry
   Percival](https://www.obeythetestinggoat.com/pages/book.html))
1. Data Structures and Algorithms ([Data Structures and Algorithms in
   Python --- Michael T. Goodrich, Roberto Tamassia and Michael H.
   Goldwasser](http://bcs.wiley.com/he-bcs/Books?action=index&itemId=1118290275&bcsId=8029))
